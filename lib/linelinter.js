// Generated by CoffeeScript 1.3.3

/*
CoffeeLint

Copyright (c) 2011 Matthew Perpick.
Modified 2012 by gareth@classdojo.com (Gareth Aye)
CoffeeLint is freely distributable under the MIT license.
*/


(function() {
  var CoffeeScript, LineLinter, coffeelint,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  coffeelint = require("./coffeelint");

  CoffeeScript = require("coffee-script");

  LineLinter = (function() {

    function LineLinter(source, config, tokensByLine) {
      this.source = source;
      this.config = config;
      this.tokensByLine = tokensByLine;
      this.lines = this.source.split("\n");
      this.lineCount = this.lines.length;
      this.line = null;
      this.lineNumber = 0;
    }

    LineLinter.prototype.lint = function() {
      var errors, line, lineNumber, _i, _len, _ref;
      errors = [];
      _ref = this.lines;
      for (lineNumber = _i = 0, _len = _ref.length; _i < _len; lineNumber = ++_i) {
        line = _ref[lineNumber];
        this.lineNumber = lineNumber;
        this.line = line;
        errors = errors.concat(this.lintLine());
      }
      return errors;
    };

    LineLinter.prototype.lintLine = function() {
      var errors;
      if (!this.lineHasToken()) {
        return [];
      }
      errors = [];
      errors.push(this.checkTabs());
      errors.push(this.checkTrailingWhitespace());
      errors.push(this.checkLineLength());
      errors.push(this.checkTrailingSemicolon());
      errors.push(this.checkLineEndings());
      errors.push(this.checkComments());
      return errors.filter(function(error) {
        return error !== null;
      });
    };

    LineLinter.prototype.checkTabs = function() {
      var indentation;
      indentation = this.line.split(coffeelint.Regexes.INDENTATION)[0];
      if (__indexOf.call(indentation, "\t") >= 0) {
        return this.createLineError("no_tabs");
      } else {
        return null;
      }
    };

    LineLinter.prototype.checkTrailingWhitespace = function() {
      var whitespace;
      whitespace = coffeelint.Regexes.TRAILING_WHITESPACE.test(this.line);
      if (whitespace) {
        return this.createLineError("no_trailing_whitespace");
      } else {
        return null;
      }
    };

    LineLinter.prototype.checkLineLength = function() {
      var max, rule, _ref;
      rule = "max_line_length";
      max = (_ref = this.config[rule]) != null ? _ref.value : void 0;
      if (max && max < this.line.length) {
        return this.createLineError(rule);
      } else {
        return null;
      }
    };

    LineLinter.prototype.checkTrailingSemicolon = function() {
      var first, last, newline, semicolon, _i, _ref;
      semicolon = coffeelint.Regexes.TRAILING_SEMICOLON.test(this.line);
      _ref = this.getLineTokens(), first = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), last = _ref[_i++];
      newline = last && (last.newLine != null);
      if (semicolon && !newline) {
        return this.createLineError("no_trailing_semicolons");
      } else {
        return null;
      }
    };

    LineLinter.prototype.checkLineEndings = function() {
      var ending, lastChar, rule, valid, _ref;
      rule = "line_endings";
      ending = (_ref = this.config[rule]) != null ? _ref.value : void 0;
      if (!ending || this.isLastLine() || !this.line) {
        return null;
      }
      lastChar = this.line[this.line.length - 1];
      valid = (function() {
        if (ending === "windows") {
          return lastChar === "\r";
        } else if (ending === "unix") {
          return lastChar !== "\r";
        } else {
          throw new Error("unknown line ending type: " + ending);
        }
      })();
      if (!valid) {
        return this.createLineError(rule, {
          context: "Expected " + ending
        });
      } else {
        return null;
      }
    };

    LineLinter.prototype.checkComments = function() {
      var cmd, r, result, rules, _i, _len, _ref;
      result = coffeelint.Regexes.CONFIG_STATEMENT.exec(this.line);
      if (result != null) {
        cmd = result[1];
        rules = [];
        if (result[2] != null) {
          _ref = result[2].split(",");
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            r = _ref[_i];
            rules.push(r.replace(/^\s+|\s+$/g, ""));
          }
        }
        blockConfig[cmd][this.lineNumber] = rules;
      }
      return null;
    };

    LineLinter.prototype.createLineError = function(rule, attrs) {
      var _ref;
      if (attrs == null) {
        attrs = {};
      }
      attrs.lineNumber = this.lineNumber + 1;
      attrs.level = (_ref = this.config[rule]) != null ? _ref.level : void 0;
      return coffeelint.createError(rule, attrs);
    };

    LineLinter.prototype.isLastLine = function() {
      return this.lineNumber === this.lineCount - 1;
    };

    LineLinter.prototype.lineHasToken = function() {
      return this.tokensByLine[this.lineNumber] != null;
    };

    LineLinter.prototype.getLineTokens = function() {
      return this.tokensByLine[this.lineNumber] || [];
    };

    return LineLinter;

  })();

  module.exports = LineLinter;

}).call(this);
