// Generated by CoffeeScript 1.3.3
(function() {
  var CoffeeScript, LexicalLinter, coffeelint,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  coffeelint = require("./coffeelint");

  CoffeeScript = require("coffee-script");

  LexicalLinter = (function() {

    function LexicalLinter(source, config) {
      this.source = source;
      this.tokens = CoffeeScript.tokens(source);
      this.config = config;
      this.i = 0;
      this.tokensByLine = {};
      this.arrayTokens = [];
      this.parenTokens = [];
      this.callTokens = [];
      this.lines = source.split("\n");
    }

    LexicalLinter.prototype.lint = function() {
      var error, errors, i, token, _i, _len, _ref;
      errors = [];
      _ref = this.tokens;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        token = _ref[i];
        this.i = i;
        error = this.lintToken(token);
        if (error) {
          errors.push(error);
        }
      }
      return errors;
    };

    LexicalLinter.prototype.lintToken = function(token) {
      var lineNumber, type, value, _base, _ref;
      type = token[0], value = token[1], lineNumber = token[2];
      if ((_ref = (_base = this.tokensByLine)[lineNumber]) == null) {
        _base[lineNumber] = [];
      }
      this.tokensByLine[lineNumber].push(token);
      this.lineNumber = lineNumber || this.lineNumber || 0;
      switch (type) {
        case "IDENTIFIER":
          return this.lintIdentifier(token);
        case "INDENT":
          return this.lintIndentation(token);
        case "CLASS":
          return this.lintClass(token);
        case "{":
          return this.lintBrace(token);
        case "++":
        case "--":
          return this.lintIncrement(token);
        case "THROW":
          return this.lintThrow(token);
        case "[":
        case "]":
          return this.lintArray(token);
        case "(":
        case ")":
          return this.lintParens(token);
        case "JS":
          return this.lintJavascript(token);
        case "CALL_START":
        case "CALL_END":
          return this.lintCall(token);
        case "+":
        case "-":
          return this.lintPlus(token);
        case "=":
        case "MATH":
        case "COMPARE":
        case "LOGIC":
          return this.lintMath(token);
        default:
          return null;
      }
    };

    LexicalLinter.prototype.lintIdentifier = function(token) {
      var name;
      name = token[1];
      if (coffeelint.Regexes.IDENTIFIER.test(name)) {
        return null;
      } else if (coffeelint.Regexes.CONSTANT.test(name)) {
        return null;
      }
      return this.createLexError("identifier", {
        context: "identifier: " + name
      });
    };

    LexicalLinter.prototype.lintArray = function(token) {
      if (token[0] === "[") {
        this.arrayTokens.push(token);
      } else if (token[0] === "]") {
        this.arrayTokens.pop();
      }
      return null;
    };

    LexicalLinter.prototype.lintParens = function(token) {
      var i, n1, n2, p1;
      if (token[0] === "(") {
        p1 = this.peek(-1);
        n1 = this.peek(1);
        n2 = this.peek(2);
        i = n1 && n2 && n1[0] === "STRING" && n2[0] === "+";
        token.isInterpolation = i;
        this.parenTokens.push(token);
      } else {
        this.parenTokens.pop();
      }
      return null;
    };

    LexicalLinter.prototype.isInInterpolation = function() {
      var t, _i, _len, _ref;
      _ref = this.parenTokens;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (t.isInterpolation) {
          return true;
        }
      }
      return false;
    };

    LexicalLinter.prototype.isInExtendedRegex = function() {
      var t, _i, _len, _ref;
      _ref = this.callTokens;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (t.isRegex) {
          return true;
        }
      }
      return false;
    };

    LexicalLinter.prototype.lintPlus = function(token) {
      var isUnary, p, unaries, _ref;
      if (this.isInInterpolation() || this.isInExtendedRegex()) {
        return null;
      }
      p = this.peek(-1);
      unaries = ["TERMINATOR", "(", "=", "-", "+", ",", "CALL_START", "INDEX_START", "..", "...", "COMPARE", "IF", "THROW", "LOGIC", "POST_IF", ":", "[", "INDENT"];
      isUnary = !p ? false : (_ref = p[0], __indexOf.call(unaries, _ref) >= 0);
      if ((isUnary && token.spaced) || (!isUnary && !token.spaced && !token.newLine)) {
        return this.createLexError("space_operators", {
          context: token[1]
        });
      } else {
        return null;
      }
    };

    LexicalLinter.prototype.lintMath = function(token) {
      if (!token.spaced && !token.newLine) {
        return this.createLexError("space_operators", {
          context: token[1]
        });
      } else {
        return null;
      }
    };

    LexicalLinter.prototype.lintCall = function(token) {
      var p;
      if (token[0] === "CALL_START") {
        p = this.peek(-1);
        token.isRegex = p && p[0] === "IDENTIFIER" && p[1] === "RegExp";
        this.callTokens.push(token);
        if (token.generated) {
          return this.createLexError("no_implicit_parens");
        } else {
          return null;
        }
      } else {
        this.callTokens.pop();
        return null;
      }
    };

    LexicalLinter.prototype.lintBrace = function(token) {
      var i, t;
      if (token.generated) {
        i = -1;
        while (true) {
          t = this.peek(i);
          if (!(t != null) || t[0] === "TERMINATOR") {
            return this.createLexError("no_implicit_braces");
          }
          if (t[0] === "CLASS") {
            return null;
          }
          i -= 1;
        }
      } else {
        return null;
      }
    };

    LexicalLinter.prototype.lintJavascript = function(token) {
      return this.createLexError("no_backticks");
    };

    LexicalLinter.prototype.lintThrow = function(token) {
      var n1, n2, nextIsString, _ref;
      _ref = [this.peek(), this.peek(2)], n1 = _ref[0], n2 = _ref[1];
      nextIsString = n1[0] === "STRING" || (n1[0] === "(" && n2[0] === "STRING");
      if (nextIsString) {
        return this.createLexError("no_throwing_strings");
      }
    };

    LexicalLinter.prototype.lintIncrement = function(token) {
      var attrs;
      attrs = {
        context: "found " + token[0]
      };
      return this.createLexError("no_plusplus", attrs);
    };

    LexicalLinter.prototype.lintIndentation = function(token) {
      var context, expected, ignoreIndent, isArrayIndent, isInterpIndent, isMultiline, lineNumber, numIndents, previous, previousIndentation, previousLine, previousSymbol, type, _ref;
      type = token[0], numIndents = token[1], lineNumber = token[2];
      if (token.generated != null) {
        return null;
      }
      previous = this.peek(-2);
      isInterpIndent = previous && previous[0] === "+";
      previous = this.peek(-1);
      isArrayIndent = this.inArray() && (previous != null ? previous.newLine : void 0);
      previousSymbol = (_ref = this.peek(-1)) != null ? _ref[0] : void 0;
      isMultiline = previousSymbol === "=" || previousSymbol === ",";
      ignoreIndent = isInterpIndent || isArrayIndent || isMultiline;
      if (this.isChainedCall()) {
        previousLine = this.lines[this.lineNumber - 1];
        previousIndentation = previousLine.match(/^(\s*)/)[1].length;
        numIndents -= previousIndentation;
      }
      expected = this.config["indentation"].value;
      if (!ignoreIndent && numIndents !== expected) {
        context = ("Expected " + expected + " ") + ("got " + numIndents);
        return this.createLexError("indentation", {
          context: context
        });
      } else {
        return null;
      }
    };

    LexicalLinter.prototype.lintClass = function(token) {
      var attrs, className, offset, _ref, _ref1, _ref2;
      if ((token.newLine != null) || ((_ref = this.peek()[0]) === "INDENT" || _ref === "EXTENDS")) {
        return null;
      }
      className = null;
      offset = 1;
      while (!className) {
        if (((_ref1 = this.peek(offset + 1)) != null ? _ref1[0] : void 0) === ".") {
          offset += 2;
        } else if (((_ref2 = this.peek(offset)) != null ? _ref2[0] : void 0) === "@") {
          offset += 1;
        } else {
          className = this.peek(offset)[1];
        }
      }
      if (!coffeelint.Regexes.CAMEL_CASE.test(className)) {
        attrs = {
          context: "class name: " + className
        };
        return this.createLexError("camel_case_classes", attrs);
      } else {
        return null;
      }
    };

    LexicalLinter.prototype.createLexError = function(rule, attrs) {
      if (attrs == null) {
        attrs = {};
      }
      attrs.lineNumber = this.lineNumber + 1;
      attrs.level = this.config[rule].level;
      attrs.line = this.lines[this.lineNumber];
      return coffeelint.createError(rule, attrs);
    };

    LexicalLinter.prototype.peek = function(n) {
      if (n == null) {
        n = 1;
      }
      return this.tokens[this.i + n] || null;
    };

    LexicalLinter.prototype.inArray = function() {
      return this.arrayTokens.length > 0;
    };

    LexicalLinter.prototype.isChainedCall = function() {
      var i, lastNewLineIndex, lines, t, token, tokens;
      lines = (function() {
        var _i, _len, _ref, _results;
        _ref = this.tokens.slice(0, this.i + 1 || 9e9);
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          token = _ref[i];
          if (token.newLine != null) {
            _results.push(i);
          }
        }
        return _results;
      }).call(this);
      lastNewLineIndex = lines ? lines[lines.length - 2] : null;
      if (!(lastNewLineIndex != null)) {
        return false;
      }
      tokens = [this.tokens[lastNewLineIndex], this.tokens[lastNewLineIndex + 1]];
      return !!((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = tokens.length; _i < _len; _i++) {
          t = tokens[_i];
          if (t && t[0] === ".") {
            _results.push(t);
          }
        }
        return _results;
      })()).length;
    };

    return LexicalLinter;

  })();

  module.exports = LexicalLinter;

}).call(this);
