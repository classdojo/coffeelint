// Generated by CoffeeScript 1.3.3

/*
CoffeeLint

Copyright (c) 2011 Matthew Perpick.
Modified 2012 by gareth@classdojo.com (Gareth Aye)
CoffeeLint is freely distributable under the MIT license.
*/


(function() {
  var ASTLinter, CoffeeScript, LexicalLinter, LineLinter, blockConfig, coffeelint, defaults, extend,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ASTLinter = require("./astlinter");

  LexicalLinter = require("./lexicallinter");

  LineLinter = require("./linelinter");

  coffeelint = {};

  if (typeof exports !== "undefined" && exports !== null) {
    coffeelint = exports;
    CoffeeScript = require("coffee-script");
  } else {
    this.coffeelint = coffeelint;
    CoffeeScript = this.CoffeeScript;
  }

  coffeelint.VERSION = "0.5.2";

  coffeelint.Level = {
    ERROR: "error",
    WARN: "warn",
    IGNORE: "ignore"
  };

  coffeelint.Rule = {
    no_tabs: {
      level: coffeelint.Level.ERROR,
      message: "Line contains tab indentation"
    },
    no_trailing_whitespace: {
      level: coffeelint.Level.ERROR,
      message: "Line ends with trailing whitespace"
    },
    max_line_length: {
      value: 80,
      level: coffeelint.Level.ERROR,
      message: "Line exceeds maximum allowed length"
    },
    camel_case_classes: {
      level: coffeelint.Level.ERROR,
      message: "Class names should be camel cased"
    },
    indentation: {
      value: 2,
      level: coffeelint.Level.ERROR,
      message: "Line contains inconsistent indentation"
    },
    no_implicit_braces: {
      level: coffeelint.Level.IGNORE,
      message: "Implicit braces are forbidden"
    },
    no_trailing_semicolons: {
      level: coffeelint.Level.ERROR,
      message: "Line contains a trailing semicolon"
    },
    no_plusplus: {
      level: coffeelint.Level.IGNORE,
      message: "The increment and decrement operators are forbidden"
    },
    no_throwing_strings: {
      level: coffeelint.Level.ERROR,
      message: "Throwing strings is forbidden"
    },
    cyclomatic_complexity: {
      value: 10,
      level: coffeelint.Level.IGNORE,
      message: "The cyclomatic complexity is too damn high"
    },
    no_backticks: {
      level: coffeelint.Level.ERROR,
      message: "Backticks are forbidden"
    },
    line_endings: {
      level: coffeelint.Level.IGNORE,
      value: "unix",
      message: "Line contains incorrect line endings"
    },
    no_implicit_parens: {
      level: coffeelint.Level.IGNORE,
      message: "Implicit parens are forbidden"
    },
    space_operators: {
      level: coffeelint.Level.IGNORE,
      message: "Operators must be spaced properly"
    },
    coffeescript_error: {
      level: coffeelint.Level.ERROR,
      message: ""
    }
  };

  coffeelint.Regexes = {
    TRAILING_WHITESPACE: /[^\s]+[\t ]+\r?$/,
    INDENTATION: /\S/,
    CAMEL_CASE: /^[A-Z][a-zA-Z\d]*$/,
    TRAILING_SEMICOLON: /;\r?$/,
    CONFIG_STATEMENT: /coffeelint:\s*(disable|enable)(?:=([\w\s,]*))?/
  };

  extend = function() {
    var destination, k, source, sources, v, _i, _len;
    destination = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      for (k in source) {
        v = source[k];
        destination[k] = v;
      }
    }
    return destination;
  };

  defaults = function(source, defaults) {
    return extend({}, defaults, source);
  };

  coffeelint.createError = function(rule, attrs) {
    var level;
    if (attrs == null) {
      attrs = {};
    }
    level = attrs.level;
    if (level !== coffeelint.Level.ERROR && level !== coffeelint.Level.IGNORE && level !== coffeelint.Level.WARN) {
      throw new Error("unknown level " + level);
    }
    if (level === coffeelint.Level.ERROR || level === coffeelint.Level.WARN) {
      attrs.rule = rule;
      return defaults(attrs, coffeelint.Rule[rule]);
    } else {
      return null;
    }
  };

  blockConfig = {
    enable: {},
    disable: {}
  };

  coffeelint.lint = function(source, userConfig) {
    var allErrors, astErrors, cmd, config, difference, disabled, e, errors, i, initiallyDisabled, k, lexErrors, lexicalLinter, line, lineErrors, lineLinter, lines, nextLine, r, rules, s, tokensByLine, v, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;
    if (userConfig == null) {
      userConfig = {};
    }
    lines = source.split("\n");
    config = {};
    _ref = coffeelint.Rule;
    for (k in _ref) {
      v = _ref[k];
      config[k] = defaults(userConfig[k], v);
    }
    initiallyDisabled = [];
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      line = lines[_i];
      s = coffeelint.Regexes.CONFIG_STATEMENT.exec(line);
      if ((s != null) && s.length > 2 && __indexOf.call(s, "enable") >= 0) {
        _ref1 = s.slice(1);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          r = _ref1[_j];
          if (r !== "enable" && r !== "disable") {
            if (!(r in config && ((_ref2 = config[r].level) === "warn" || _ref2 === "error"))) {
              initiallyDisabled.push(r);
              config[r] = {
                level: "error"
              };
            }
          }
        }
      }
    }
    astErrors = new ASTLinter(source, config).lint();
    lexicalLinter = new LexicalLinter(source, config);
    lexErrors = lexicalLinter.lint();
    tokensByLine = lexicalLinter.tokensByLine;
    lineLinter = new LineLinter(source, config, tokensByLine);
    lineErrors = lineLinter.lint();
    errors = lexErrors.concat(lineErrors, astErrors);
    errors.sort(function(a, b) {
      return a.lineNumber - b.lineNumber;
    });
    difference = function(a, b) {
      var j, _ref3, _results;
      j = 0;
      _results = [];
      while (j < a.length) {
        if (_ref3 = a[j], __indexOf.call(b, _ref3) >= 0) {
          _results.push(a.splice(j, 1));
        } else {
          _results.push(j++);
        }
      }
      return _results;
    };
    allErrors = errors;
    errors = [];
    disabled = initiallyDisabled;
    nextLine = 0;
    for (i = _k = 0, _ref3 = lines.length; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; i = 0 <= _ref3 ? ++_k : --_k) {
      for (cmd in blockConfig) {
        rules = blockConfig[cmd][i];
        if (rules != null) {
          ({
            "disable": function() {
              return disabled = disabled.concat(rules);
            },
            "enable": function() {
              difference(disabled, rules);
              if (rules.length === 0) {
                return disabled = initiallyDisabled;
              }
            }
          })[cmd]();
        }
      }
      while (nextLine === i && allErrors.length > 0) {
        nextLine = allErrors[0].lineNumber - 1;
        e = allErrors[0];
        if (e.lineNumber === i + 1 || !(e.lineNumber != null)) {
          e = allErrors.shift();
          if (_ref4 = e.rule, __indexOf.call(disabled, _ref4) < 0) {
            errors.push(e);
          }
        }
      }
    }
    blockConfig = {
      "enable": {},
      "disable": {}
    };
    return errors;
  };

}).call(this);
